{"version":3,"sources":["util.js","lib.js","gameOfLife.js","App.js","index.js"],"names":["concat","list1","list2","convertToLinear","matrix","reduce","isIncludes","source","element","includes","increamentList","begin","end","size","Array","fill","map","x","i","splitNumbers","stringOfnumbers","split","createBoard","bound","topLeft","xPrime","bottomRight","y","yPrime","addRows","bind","rowNumber","joinIndexes","item1","item2","row","push","allPossibleNeighbours","cell","neighbours","set1","set2","result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","valueOfSet1","value","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","valueOfSet2","err","return","cartesionProduct","index","toString","indexOf","splice","isAlive","liveCells","validCells","neighbourCells","isValid","filter","extractNeighbours","liveCellsString","aliveNeighbours","isContain","intersection","willRemainAlive","length","willComeAlive","nextGeneration","currGeneration","bounds","world","isCellAlive","Button","react_default","a","createElement","id","this","props","className","onClick","clickListener","Component","Cell","Row","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","indexes","createCells","assertThisInitialized","_this2","App_Cell","key","World","_this3","createWorldGrid","_this4","App_Row","App","_this5","state","startGame","endGame","initializeLiveCells","_this6","intervalId","setInterval","updateLiveCells","clearInterval","setState","nextGenerationLiveCells","event","target","App_World","App_Button","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.289ad04a.chunk.js","sourcesContent":["const cartesionProduct = function(set1, set2) {\n  let result = [];\n  for (let valueOfSet1 of set1) {\n    for (let valueOfSet2 of set2) {\n      result.push([valueOfSet1, valueOfSet2]);\n    }\n  }\n  return result;\n};\n\nconst joinWithComa = function(item1, item2) {\n  return item1 + ',' + item2;\n};\n\nconst createUniqueList = function(size, element) {\n  return new Array(size).fill(element);\n};\n\nconst concat = function(list1, list2) {\n  return list1.concat(list2);\n};\n\nconst convertToLinear = function(matrix) {\n  return matrix.reduce(concat, []);\n};\n\nconst isIncludes = function(source, element) {\n  return source.includes(element);\n};\n\nconst increamentList = function(begin, end) {\n  let size = end - begin + 1;\n  if (size < 0) {\n    return [];\n  }\n  return new Array(size).fill(begin).map((x, i) => x + i);\n};\n\nconst intersection = function(set1, set2) {\n  let isContain = isIncludes.bind(null, set2);\n  return set1.filter(isContain);\n};\n\nconst splitNumbers = function(stringOfnumbers) {\n  let list = [];\n  list = stringOfnumbers.split(',');\n  return list.map(x => +x);\n};\n\nexport {\n  isIncludes,\n  increamentList,\n  cartesionProduct,\n  joinWithComa,\n  createUniqueList,\n  concat,\n  convertToLinear,\n  intersection,\n  splitNumbers\n};\n","import {\n  intersection,\n  increamentList,\n  joinWithComa,\n  convertToLinear,\n  cartesionProduct,\n  isIncludes\n} from './util';\n\nconst createBoard = function(bound) {\n  let x = bound.topLeft[0];\n  let xPrime = bound.bottomRight[0];\n  let y = bound.topLeft[1];\n  let yPrime = bound.bottomRight[1];\n  let rows = increamentList(x, xPrime);\n  return rows.reduce(addRows.bind(null, y, yPrime), []);\n};\n\nconst addRows = function(y, yPrime, matrix, rowNumber) {\n  let joinIndexes = joinWithComa.bind(null, rowNumber);\n  let row = increamentList(y, yPrime).map(joinIndexes);\n  matrix.push(row);\n  return matrix;\n};\n\nconst allPossibleNeighbours = function(cell) {\n  let x = +cell.split(',')[0];\n  let y = +cell.split(',')[1];\n  let neighbours = cartesionProduct([x - 1, x, x + 1], [y - 1, y, y + 1]);\n  neighbours = neighbours.map(x => x.toString());\n  let index = neighbours.indexOf(cell);\n  neighbours.splice(index, 1);\n  return neighbours;\n};\n\nconst extractNeighbours = function(bound, cell) {\n  let validCells = convertToLinear(createBoard(bound));\n  let neighbourCells = allPossibleNeighbours(cell);\n  let isValid = isIncludes.bind(null, validCells);\n  return neighbourCells.filter(isValid);\n};\n\nconst isAlive = function(liveCells, bound, cell) {\n  let neighbours = extractNeighbours(bound, cell);\n  let liveCellsString = liveCells.map(x => x.toString());\n  let aliveNeighbours = intersection(neighbours, liveCellsString);\n  let willRemainAlive =\n    aliveNeighbours.length === 2 && liveCellsString.includes(cell);\n  let willComeAlive = aliveNeighbours.length === 3;\n  return willRemainAlive || willComeAlive;\n};\n\nconst calculateWidth = function(world) {\n  let lastRow = world[world.length - 1];\n  let row = lastRow.length;\n  let column = lastRow[row - 1].length + 2;\n  return { row: +row, column: +column };\n};\n\nexport {\n  createBoard,\n  addRows,\n  allPossibleNeighbours,\n  extractNeighbours,\n  isAlive,\n  calculateWidth\n};\n","import { convertToLinear, splitNumbers } from './util.js';\nimport { isAlive, createBoard } from './lib.js';\n\nconst nextGeneration = function(currGeneration, bounds) {\n  let world = convertToLinear(createBoard(bounds));\n  let isCellAlive = isAlive.bind(null, currGeneration, bounds);\n  return world.filter(isCellAlive).map(splitNumbers);\n};\n\nexport default nextGeneration;\n\n/*\ndescribe('nextGeneration', () => {\n  it('should generate an empty generation for a current generation that contains only one live cell', () => {\n    let currentGeneration = [[0, 1]];\n    let bounds = { topLeft: [0, 0], bottomRight: [3, 3] };\n    let actualNextGen = nextGeneration(currentGeneration, bounds);\n    assert.deepEqual(actualNextGen, []);\n  });\n\n  it('should generate an empty generation for a current generation that contains multiple live cells', () => {\n    let currentGeneration = [[0, 0], [0, 1], [1, 0], [2, 2], [2, 3], [3, 3]];\n    let bounds = { topLeft: [0, 0], bottomRight: [3, 3] };\n    let expectedList = [\n      [0, 0],\n      [0, 1],\n      [1, 0],\n      [1, 2],\n      [2, 2],\n      [2, 3],\n      [3, 2],\n      [3, 3]\n    ];\n    let actualNextGen = nextGeneration(currentGeneration, bounds);\n    assert.deepEqual(actualNextGen, expectedList);\n  });\n\n  it('should generate a vertical blinker as the next step of a horizontal blinker', () => {\n    let currentGeneration = [[0, 1], [1, 1], [2, 1]];\n    let expectedNextGen = [[1, 0], [1, 1], [1, 2]];\n    let bounds = { topLeft: [0, 0], bottomRight: [3, 3] };\n    let actualNextGen = nextGeneration(currentGeneration, bounds);\n    assert.ok(isSame(actualNextGen, expectedNextGen));\n    assert.ok(isSameArity(actualNextGen, expectedNextGen));\n  });\n\n  it('should kill cells not within bounds', () => {\n    let currentGeneration = [[0, 1], [0, 2], [0, 3]];\n    let expectedNextGen = [];\n    let bounds = { topLeft: [1, 1], bottomRight: [3, 3] };\n    let actualNextGen = nextGeneration(currentGeneration, bounds);\n    assert.ok(isSame(actualNextGen, expectedNextGen));\n    assert.ok(isSameArity(actualNextGen, expectedNextGen));\n  });\n});\n*/\n","import React, { Component } from 'react';\nimport { createBoard } from './lib';\nimport nextGeneration from './gameOfLife';\n\nimport './App.css';\n\nclass Button extends Component {\n  render() {\n    return (\n      <div\n        id={this.props.value}\n        className=\"btn\"\n        onClick={this.props.clickListener}\n      >\n        {this.props.value}\n      </div>\n    );\n  }\n}\n\nconst Cell = function(props) {\n  const className = props.isAlive ? 'aliveCells' : 'deadCells';\n  return (\n    <td id={props.index} className={className} onClick={props.clickListener} />\n  );\n};\n\nclass Row extends Component {\n  constructor(props) {\n    super(props);\n    this.indexes = props.indexes;\n    this.liveCells = props.liveCells;\n    this.clickListener = props.clickListener;\n    this.createCells = this.createCells.bind(this);\n  }\n\n  createCells() {\n    const row = this.indexes.map((cell, index) => {\n      const isCellAlive = this.liveCells.includes(cell);\n      return (\n        <Cell\n          key={index}\n          index={cell}\n          isAlive={isCellAlive}\n          clickListener={this.clickListener}\n        />\n      );\n    });\n    return row;\n  }\n\n  render() {\n    this.liveCells = this.props.liveCells;\n    return <tr>{this.createCells()}</tr>;\n  }\n}\n\nclass World extends Component {\n  constructor(props) {\n    super(props);\n    this.bound = props.bound;\n    this.liveCells = props.liveCells;\n    this.clickListener = props.clickListener;\n    this.createWorldGrid = this.createWorldGrid.bind(this);\n  }\n\n  createWorldGrid() {\n    const world = createBoard(this.bound);\n    const rows = world.map((row, index) => {\n      return (\n        <Row\n          key={index}\n          indexes={row}\n          liveCells={this.liveCells}\n          clickListener={this.clickListener}\n        />\n      );\n    });\n    return rows;\n  }\n\n  render() {\n    this.liveCells = this.props.liveCells;\n    return (\n      <table className=\"worldGrid\">\n        <tbody>{this.createWorldGrid()}</tbody>\n      </table>\n    );\n  }\n}\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.bound = props.bound;\n    this.state = {\n      liveCells: []\n    };\n\n    this.startGame = this.startGame.bind(this);\n    this.endGame = this.endGame.bind(this);\n    this.initializeLiveCells = this.initializeLiveCells.bind(this);\n  }\n\n  startGame() {\n    const intervalId = setInterval(() => {\n      this.updateLiveCells();\n      if (this.state.liveCells.length === 0) clearInterval(intervalId);\n    }, 500);\n  }\n\n  endGame() {\n    this.setState({\n      liveCells: []\n    });\n  }\n\n  updateLiveCells() {\n    const nextGenerationLiveCells = nextGeneration(\n      this.state.liveCells,\n      this.bound\n    );\n\n    this.setState({\n      liveCells: nextGenerationLiveCells.map(x => x.toString())\n    });\n  }\n\n  initializeLiveCells(event) {\n    const cell = event.target.id;\n    this.setState({\n      liveCells: this.state.liveCells.concat(cell)\n    });\n  }\n\n  render() {\n    return (\n      <main>\n        <p className=\"header\">The Game Of Life</p>\n        <div className=\"world\">\n          <World\n            bound={this.bound}\n            liveCells={this.state.liveCells}\n            clickListener={this.initializeLiveCells}\n          />\n        </div>\n        <div className=\"footer\">\n          <Button clickListener={this.startGame} value=\"START\" />\n          <Button clickListener={this.endGame} value=\"STOP\" />\n        </div>\n      </main>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst BOUNDS = { topLeft: [0, 0], bottomRight: [20, 20] };\n\nReactDOM.render(<App bound={BOUNDS} />, document.getElementById('root'));\n"],"sourceRoot":""}